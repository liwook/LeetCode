​

## 309.最佳买卖股票时机含冷冻期

**题目：**

给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
示例: 输入: [1,2,3,0,2] 输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]

思路：
本题和之前的力扣股票题目多了个冷冻期。

但是我觉得**把这个冷冻期当做当天强迫不能操作状态**就好，不要过多理会这个冷冻期，这样就好理解了。

**1.确定dp数组的含义和下标定义**

首先就确定一天就可以有3种状态：

	0：持有股票状态（也是买入状态）

	1：不持有股票状态（也是买入状态）

	2：不操作状态（也就是冷冻期）

二维数组dp[i][j]:第i天状态为j，所剩的最多现金为dp[i][j]。

**2.确定递推公式**

1）持有股票状态

        1）保持前一天的状态就行，前一天是持有股票状态

        2）前一天就是不操作状态

**持有股票状态只能由这两种情况构成**

dp[i][0]=max(dp[i-1][0],dp[i-1][2]);

2)不持有股票状态

        1）维持前一天不持有股票状态

        2）当天卖掉股票

dp[i][1]=max(dp[i-1][1],dp[i-1][0]+prices[i]);

3)不操作状态（冷冻期）

就只有一种情况：前一天是卖出股票状态

dp[i][2]=dp[i-1][1];

**3.初始化dp数组**

``` c++
dp[0][0]=-prices[0];    //买入

dp[0][1]=0;      //卖出，因为没有买入，所以就是0了

dp[0][2]=0;        //不操作
```

**4.确定遍历顺序**

从递推公式可以知道遍历顺序是从前往后

``` c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n=prices.size();
        vector<vector<int>> dp(n,vector<int>(3));
        dp[0][0]=-prices[0];    //dp[i][0]表示买入
        dp[0][1]=0;     //dp[i][1]表示卖出
        dp[0][2]=0;

        for(int i=1;i<n;++i){
            dp[i][0]=max({dp[i-1][0],dp[i-1][2]-prices[i]});
            dp[i][1]=max(dp[i-1][0]+prices[i],dp[i-1][1]);
            dp[i][2]=dp[i-1][1];
        }
        return max(dp[n-1][1],dp[n-1][2]);
    }
};
```

**牢记**：这题目就不要挂念这冷冻期，这就是当天不操作股票；用一天有3种状态来分析，处理好递推公式就好理解了。

​