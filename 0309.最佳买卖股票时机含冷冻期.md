​
题目：

给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
示例: 输入: [1,2,3,0,2] 输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]

**思路：**
本题和之前的力扣股票题目多了个冷冻期。

这道题不要理会冷冻期就好理解了。每天的状态就只有两种，**持有股票和不持有股票**。

因为卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)这个原因，我们就需要再**细分不持有股票的状态**。

### 1.确定dp数组的含义和下标定义

首先就确定一天就可以有3种状态：

1）持有股票状态

        状态0：持有股票状态

2）不持有股票（这个需要细分）

        状态1：不持有股票，**是因为当天卖出股票**

       状态 2：不持有股票并且**当天没有卖出股票的**

二维数组dp[i][j]:第i天状态为j，所剩的最多现金为dp[i][j]。

### 2.确定递推公式

1）持有股票状态

       ①保持前一天的状态，那么前一天是持有股票状态

       ②当天买入股票，那么前一天就是不持有股票状态，那么是不持有股票状态中的哪一种呢

只能是状态 2：不持有股票并且当天没有卖出股票的。

如果是状态1：不持有股票，是因为当天卖出股票，那因为冷冻期的原因，今天就不能买入股票了，所以前一天只能是状态2.

        dp[i][0]=max(dp[i-1][0],dp[i-1][2]-prices[i]);

2)不持有股票状态

  状态1：不持有股票，是因为当天卖出股票

                当天可以卖出股票，那说明前一天是持有股票的状态，即状态0        

                 dp[i][1]=dp[i-1][0]+prices[i];

状态2：不持有股票并且当天没有卖出股票

        ①前一天也是状态2:持有股票并且当天没有卖出股票，所以当天就继续维持状态2 就行

        ②前一天是状态1，前一天卖出股票了，那么当天就符合不持有股票并且当天没有卖出股票的状态了，所以当天就继续维持状态1就行

dp[i][2]=max(dp[i-1][2],dp[i-1][1]);

### 3.初始化dp数组

``` cpp
dp[0][0]=-prices[0];    //保持买入

dp[0][1]=0;        //保持不持有，当天卖出，卖出，因为没有买入，所以就是0了

dp[0][2]=0;        //保持不持有，并且当天没有卖出
```

#### 4.确定遍历顺序

从递推公式可以知道遍历顺序是从前往后

**代码实现：**

``` cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n=prices.size();
        vector<vector<int>> dp(n,vector<int>(3));
        dp[0][0]=-prices[0];    //dp[i][0]表示买入
        dp[0][1]=0;    
        dp[0][2]=0;

        for(int i=1;i<n;++i){
         for(int i=1;i<n;++i){
            dp[i][0]=max(dp[i-1][0],dp[i-1][2]-prices[i]);
            dp[i][1]=dp[i-1][0]+prices[i];
            dp[i][2]=max(dp[i-1][2],dp[i-1][1]);
        }
        return max(dp[n-1][1],dp[n-1][2]);
    }
};
```

**牢记**：这题目就不要挂念这冷冻期，要**把不持有股票状态进行细分**；用一天有3种状态来分析，处理好递推公式就好理解了。

​