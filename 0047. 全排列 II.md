​
**题目：**

给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。

示例 1：

输入：nums = [1,1,2]
输出： [[1,1,2], [1,2,1], [2,1,1]]
示例 2：

输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

## 解题思路：

这是个排列的题目，可以使用回溯算法。

这道题就是不明白代码中的**used[i - 1] == false**这个为什么就能去重同一层的出现相同数字的情况
```cpp
 if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) 
     continue;
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/4b0fe4d0b56e463bbd5a97b1810aae4f.png#pic_center)


 该图片来自代码随想录。这里的说法还是看不明白，**为什么used[i-1]==0说明同一树层上有重复的元素nums[i]和nums[i-1]**呢？？？为什么呢？？

**我的理解：**

**想法1：**

nums[i - 1]一定比nums[i]先被取值和判断。如果nums[i - 1]被取值了，那used[i - 1]会被置1（如上图的第2层，取了第一个元素1），只有**当递归再回退到这一层（上图的第1层）时再将它置0**。

写 used[i - 1]==false 是因为 nums[i - 1] 在深度优先遍历的过程中刚刚被撤销选择，也就是重置为false。比如在第二层时候取了第一个1，那么当递归再回退到第一层的时候，就被撤销选择，即是重置为false。

再在第二层取第二个1时候，used[i-1]==false,这样就**说明nums[i - 1]和nums[i]是属于同一层递归中的。（因为这是经过撤销选择回退到上一层，想使用nums[i]的时候，这个nums[i]就和nums[i-1]是在同一层的了）**。

在同一父节点的同一层，也就是我们要用这两个数放在数组中的同一个位置上，这就是我们要去重的情况。


**想法2（别人的解法）：**

**保证相同元素在排列中的相对位置保持不变**。

这个地方理解起来就需要一些技巧性了。为了方便研究，把相同的元素用上标 ' 以示区别。

假设输入为 nums = [1,2,2']，标准的全排列算法会得出如下答案：
[
    [1,2,2'],[1,2',2],
    [2,1,2'],[2,2',1],
    [2',1,2],[2',2,1]
]

在 nums = [1,2,2'] 这个例子，我保持排列中 2 一直在 2' 前面。

这样的话，从上面 6 个排列中只能挑出 3 个排列符合这个条件：
[ [1,2,2'],[2,1,2'],[2,2',1] ]
这也就是正确答案。

进一步，如果 nums = [1,2,2',2'']，我只要保证重复元素 2 的相对位置固定，比如说 2 -> 2' -> 2''，也可以得到无重复的全排列结果。

仔细思考，应该很容易明白其中的原理：

标准全排列算法之所以出现重复，是**因为把相同元素形成的排列序列视为不同的序列，但实际上它们应该是相同的；而如果固定相同元素形成的序列顺序，当然就避免了重复**。

那么反映到代码上，注意看这个剪枝逻辑：

// 新添加的剪枝逻辑，固定相同的元素在排列中的相对位置
if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
    // 如果前面的相邻相等元素没有用过，则跳过
    continue;
}

当出现重复元素时，比如输入 nums = [1,2,2',2'']，**2' 只有在 2 已经被使用的情况下才会被选择，2'' 只有在 2' 已经被使用的情况下才会被选择，这就保证了相同元素在排列中的相对位置保证固定。**

就比如说：一种排列：[1,2,2',2''],那也有另一种排列[1,2,2'',2'],我们明白这个两种排序都是一样的，是需要去重的。而第二种排列就不能保证相同元素在排列中的相对位置保证固定，所以第二种排列就要去掉。

好了，这样包含重复输入的排列问题也解决了。

我觉得**想法2**比较好理解哈。

整体代码：

```cpp
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking (vector<int>& nums, vector<bool>& used) {
        // 此时说明找到了一组
        if (path.size() == nums.size()) {
            result.push_back(path);
            return;
        }
        for (int i = 0; i < nums.size(); i++) {
            // 如果同一树层nums[i - 1]使用过则直接跳过
            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false)
                continue;

            if (used[i] == false) {
                used[i] = true;
                path.push_back(nums[i]);
                backtracking(nums, used);
                path.pop_back();
                used[i] = false;
            }
        }
    }
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        sort(nums.begin(), nums.end()); // 排序
        vector<bool> used(nums.size(), false);
        backtracking(nums, used);
        return result;
    }
}
```

​
