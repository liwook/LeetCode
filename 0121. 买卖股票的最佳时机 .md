
​

# 121. 买卖股票的最佳时机

**题目内容：**

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

示例 1：  
输入：[7,1,5,3,6,4]  
输出：5  
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

这说明只能买入一次，卖出一次，切记。

疑问：这里主要是用贪心算法和动态规划算法没能正确做出来。

## 解法1：暴力算法

该方法超时了哈。



```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int result = 0;
        int sum=0;
        for (int i = 0; i < prices.size()-1; i++) {
                //获取从下标[i+1, prices.size()-1]范围内的最大值
                sum=*std::max_element(prices.begin()+i+1,prices.end())-prices[i];
                result=max(result,sum);        //接着逐次比较，取最大值
            }
        }
        return result;
    }
};
```


## 解法2：贪心算法

之前想的是如何找到左最小值，可是就不知该怎么写代码，

直接看代码吧。

这句代码 low=min(low,prices[i]);解答了我的不知该怎么写代码的困惑。。

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int result = 0;
        int low=0;
        
        int n=prices.size();
        for(int i=0;i<n;++i){
            low=min(low,prices[i]);//这里是保存走到下标为i为止的最小值，这样就可以是找到左侧最小值
            //（当前下标元素-保存走到下标为i为止的最小值）与result做比较
            result=max(prices[i]-low,result);
        }
    }
};
```



## 解法3：动态规划

用了数组dp[n],一开始用了一维数组，没有想到二维数组，用来表示两种状态：持有股票，不持有股票。

所以需要用二维数组vector<int> dp(n,vector<int>(2));

按照《代码随想录》的动态五步曲做法：

**1.确定数组dp及其下标的含义**

dp[i][0]表示第i天持有股票的所得的最多现金。

这里要解决的困惑：那第0天一开始就买入股票，那持有股票所得的最多现金是多少呢？一开是现金是0，那买入股票后，那持有的现金就是0-prices[0];这是为了配合数组的含义。

还有一点：买入和持有是有区别的，持有状态可以是当天买入就表示持有状态，也可以在前一天买入，当天不操作，那当天也是持有状态的。

dp[i][1]表示第i天不持有股票所得的最多现金。

**2.分析出递推公式**

第i天持有股票:可由两个状态推导出来

1）可维持前一天的持有状态

2）可由前一天是不持有状态，当天买入股票；因为买入股票只能买入一次，所以当天买买入的话，那之前都是没有买入过的（数组含义持有或不持有股票所得的最多现金，那买入股票，所以是要减去当前的股票价钱 ）

dp[i][0]=max(dp[i-1][0],-prices[i]);

第i天不持有股票：

1）可维持前一天的不持有状态

2）前一天持有股票的，当天就卖出股票

dp[i][1]=max(dp[i-1][1],dp[i-1][0]+prices[i]);

**3.dp数组初始化**

由递推公式dp[i][0]=max(dp[i-1][0],-prices[i])可知，需要从 dp[0][0] 和 dp[0][1] 推导出来。

当天持有股票，因为是第一天，那肯定是买入的，所以dp[0][0]=-prices[0];

当天不持有股票，因为是第一天，那没有买入也没卖出，所以dp[0][1]=0;

**4.确定遍历顺序**

从递推公式可以看出dp[i][0]是有从dp[i-1][0]这些推导出来的，所以是从前往后遍历。

**5.举例推导数组**

这里是为了验证的，当提交答案错误时，可以去打印dp数组去查看是哪出错的。

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        if (len == 0) return 0;
        vector<vector<int>> dp(len, vector<int>(2));
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i][0] = max(dp[i - 1][0], -prices[i]);
            dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);
        }

        //答案是dp[len-1][1],因为最终不持有股票那肯定是获得的钱最多的
        return dp[len - 1][1];
    }
};
```


这题之前也是做过的了，就是再次做到，也有点没想法，贪心的不知怎么写，而动态规划的没想到用二维数组来表示两种状态。

​
